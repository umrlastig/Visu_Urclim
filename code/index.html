<!DOCTYPE html>
<!-- Pour lancer serveur python : aller dans anaconda prompt, cd ...le bon dossier, python -m http.server
	et ensuite aller sur localhost:8000 -->
<html>
  <head>
    <title>Interface visualisation</title>
    <meta charset="utf-8" />

    <!--<script src="js/three.js"></script>-->
    <!--<script type="module" src="js/three.module.js"></script>-->
    <script src="js/earcut.js"></script>
    <!--<script type="module" src="js/OrbitControls.js"></script>-->
    <!--
		ANCIENNE VERSION DE D3 JS ?
		<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>

	-->
	<script src="https://d3js.org/d3.v6.js"></script>
	<script src="js/jquery.js" charset="utf-8"></script>
	<script src="js/lodash.js"></script>

    <!--
		ci dessous pour double slider jquery ui
	-->
    <link
      rel="stylesheet"
      href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css"
    />
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <script src="http://www.lactame.com/lib/netcdfjs/0.3.0/netcdfjs.min.js"></script>
    <!--
		ci dessus pour double slider jquery ui
	-->

    <!-- <script src="js/add_climate_data_functions.js" charset="utf-8"></script> -->
    <!--<script src="js/load_data_functions.js" charset="utf-8"></script> -->
    <!--<script src="js/color_functions.js" charset="utf-8"></script> -->
    <!--<script src="js/buildings_functions.js" charset="utf-8"></script> -->
    <!--<script src="js/2D_vertical_planes_functions.js" charset="utf-8"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.bundle.min.js"></script>
    <link href="css/main_2.css" rel="stylesheet" />

    <!--
		ci dessous la librairie leaflet
	-->
    <link
      rel="stylesheet"
      href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css"
    />
    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>

    <!--
		ci dessous la librairie proj4
	-->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.2/proj4.js"
      integrity="sha512-xDJcBRHFtyIAwCxC+w+BUE8S20UdKmyHA/ZoHKZ9zgwSfQQxdgCH/5Q0i9qrsBJFZQRjy1tSmqw8VGlrEy85MQ=="
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="main">
      <span id="open_menu">
        <svg
          width="24"
          height="24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"
            fill="#fff"
          ></path>
        </svg>
      </span>
      <div id="corps">
        <div id="container"></div>
        <div id="curseur"></div>

        <div id="graph_container">
          <!-- Tab links -->
		  <div class="general_control_container_div">
			Temporal Visualisation
          </div>
          <div class="tab">
            <button id="btn_2D" class="tablinks active">
              2D
            </button>
            <button id="btn_3D" class="tablinks">
              3D
            </button>
            <button id="btn_3D_multi" class="tablinks">
              3D Multiple
            </button>
          </div>

          <!-- Tab content -->
          <div id="graph2D" class="tabcontent">
			  <div id="diagram2D">
				<canvas id="graphique2D" ></canvas>
			  </div>

          </div>

          <div id="graph3D" class="tabcontent">
			  <div id="diagram3D">
				<div id="dateViewer">Date</div>
				<canvas id="diagram3DCanvas"></canvas>
				<fieldset id="legend-box">

					<legend>Axis</legend>

					<img class = "legend" src="images/blue.png" alt="">
					<label >Date</label><br/>

					<img class = "legend" src="images/red.png" alt="">
					<label >Niveau Teb</label><br/>

					<img class = "legend" src="images/green.png" alt="">
					<label >Temperature</label><br/>
				</fieldset>
			  </div>
          </div>

          <div id="graph3D_multi" class="tabcontent">
			  <div id="diagram3D_multi">
				<canvas id="diagram3DCanvasMulti"></canvas>
        <div id="content">
        </div>
        <script id="template" type="notjs">
          <fieldset id="legend-box">

            <legend>Axis</legend>

            <img class = "legend" src="images/blue.png" alt="">
            <label >Date</label><br/>

            <img class = "legend" src="images/red.png" alt="">
            <label >Niveau Teb</label><br/>

            <img class = "legend" src="images/green.png" alt="">
            <label >Temperature</label><br/>
            </fieldset>
        </script>
			  </div>
          </div>
        </div>
      </div>

      <div id="menu_container">
        <div id="hide_menu">&times;</div>
        <div id="general_control_container">
          <div id="choose_data_label" class="general_control_container_div">
            Choose data
          </div>
          <div id="choose_data_container">
            <!-- On accède aux valeurs de ces input avec .value
					N'acceptent actuellement que des .csv -->
            <div class="choice_container">
              <label for="netcdf">Choose a netcdf :</label>
              <form method="POST" enctype="multipart/form-data">
                <input type="file" id="load_data" name="file" multiple />
                <!-- <button type="submit" role="button">Upload File</button> -->
              </form>
            </div>
            <div class="choice_container">
              <label for="data_road">Choose a road data :</label>
              <input type="file" id="data_road" accept=".geojson" />
            </div>
            <div class="choice_container">
              <label for="data_build">Choose a building data :</label>
              <input type="file" id="data_build" accept=".geojson" />
            </div>
            <div id="load_data_container">
              <script>
                function IgnoreAlpha(e) {
                  if (!e) {
                    e = window.event;
                  }
                  if ([37, 38, 39, 40].indexOf(e.keyCode) != -1) {
                    // Ignore arrow keys
                    e.returnValue = false;
                    e.cancel = true;
                  }
                }
              </script>
              <form
                id="form_load_data"
                method="POST"
                enctype="multipart/form-data"
              >
                <!-- <input id="load_data" type="file" name="file" /> -->
                <button type="submit" role="button" id="load_button">
                  Load data
                </button>
              </form>
            </div>
            <div id="data_loaded"></div>
          </div>
          <div
            id="footprint_control_label"
            class="general_control_container_div"
          >
            Footprint
          </div>
          <div id="footprint_control_container">
            <div class="footprint_control_container_inside">
              <div id="footprint_map" style="width: 30em; height: 30em"></div>
              <div id="footprint_selected">
                <button id="footprint_select">Select footprint</button>
              </div>
            </div>
          </div>
          <div id="data_control_label" class="general_control_container_div">
            Data
          </div>
          <div id="data_control_container">
            <div class="interface_labels">Date</div>
            <div id="date_control">
              <select
                id="date_control_input"
                onkeydown="IgnoreAlpha(event);"
              ></select>
            </div>
			<div class="temporal_animation_control_container">
				<div class="interface_labels">Activate temporal animation</div>
				<input
                type="checkbox"
                id="temporal_animation"
              />
			  <form action="">
				<label for="temporal_animation_time_step">Animation timestep (s):</label>
				<input type="number" id="temporal_animation_time_step" onkeydown="IgnoreAlpha(event);" min="1" value="3">
			  </form>
			</div>
            <div class="data_control_container_inside">
              <div class="interface_labels">Data displayed</div>
              <div
                id="point_control_container_sub"
                class="control_container_sub"
              >
                <div id="SBL_values" class="values_header">TEB</div>
                <div id="Meso_values" class="values_header">Meso_NH</div>
              </div>
              <div id="values_selection_sbl"></div>
              <div id="values_selection_meso"></div>
              <div id="data_block"></div>
            </div>
          </div>
          <div id="graphic_control_label" class="general_control_container_div">
            Graphic
          </div>
          <div id="graphic_control_container">
            <div class="interface_labels">Color</div>
            <div id="color_data_control">
              <select id="color_data_control_input">
                <option value="temp" selected>
                  Temperature represented by color
                </option>
                <option value="temp-fcm">
                  Temperature represented by color - fixed cm
                </option>
                <option value="level">Level represented by color</option>
              </select>
              <div id="color_temp_control">
                <div id="temp_control">
                  diff_temp
                  <div id="temp_control_input">
                    <input
                      type="text"
                      id="temp_min_input"
                      name="name"
                      value="20"
                    />
                    <input
                      type="text"
                      id="temp_max_input"
                      name="name"
                      value="30"
                    />
                  </div>
                </div>
                <!--<div id="color_class_control">
								<select id="color_class_control_input">
									<option value="effectifs_egaux" >Effectifs égaux</option>
									<option value="ecarts_egaux" selected>Intervalles égaux</option>
								</select>
							</div>-->
                <div id="temp_histogram_content"></div>
              </div>
              <div id="color_control">
                <!--<div id="color_control_input" value ="">
							</div>-->
              </div>
            </div>
            <div class="interface_labels">horizontal planes</div>
            <div id="transparency_control">
              <div id="transparency_control_label">transparency_factor: 1</div>
              <div id="transparency_control_input">
                <div class="slider" id="transparency_slider"></div>
              </div>
            </div>
            <div class="interface_labels">vertical planes</div>
            <div id="vertical_plane_transparency_control">
              <div id="vertical_plane_transparency_label">
                vertical_plane_transparency_factor: 1
              </div>
              <div id="vertical_plane_transparency_control_input">
                <div
                  class="slider"
                  id="vertical_plane_transparency_slider"
                ></div>
              </div>
            </div>

			<div id="container_plans">Type de plans :
				<form name="planForm">
				  <label for="discrete_plans">discrete values</label>
				  <input type="radio" id="discrete_planes" name="planes" value="discrete" checked />

				  <label for="interpolated_plans_2">interpolated values 3</label>
				  <input type="radio" id="interpolated_planes_2" name="planes" value="interp_3" />
				  <label for="interpolated_plans">interpolated values 2</label>
				  <input type="radio" id="interpolated_planes_3" name="planes" value="interp_2" />

				</form>
			</div>

            <div class="interface_labels">point cloud</div>
            <div id="container_nuage_points">Type de points :</div>
            <div id="points_transparency_control">
              <div id="points_transparency_control_label">
                points_transparency_factor: 1
              </div>
              <div id="points_transparency_control_input">
                <div class="slider" id="points_transparency_slider"></div>
              </div>
            </div>
            <div class="interface_labels">3D point cloud</div>
            <div id="size_control" class="mono_slider_container">
              <div id="size_control_label">Size:</div>
              <input
                type="text"
                id="size_text_input"
                class="mono_slider_input"
                name="name"
              />
              <div class="slider mono_slider" id="size_slider"></div>
            </div>
            <div id="relative_size_control">
              <div id="relative_size_factor_control_label">
                relative_size_factor: 0
              </div>
              <div id="relative_size_control_input">
                <div class="slider" id="relative_size_factor_size_slider"></div>
              </div>
            </div>
            <div id="density_control" class="mono_slider_container">
              <div id="density_control_label">general density:</div>
              <div id="gnl_density">
                <input
                  type="text"
                  id="density_text_input"
                  class="mono_slider_input"
                  name="name"
                />
                <div class="slider mono_slider" id="density_slider"></div>
              </div>
            </div>
            <div id="relative_density_factor_control">
              <div id="relative_density_factor_control_label">
                relative_density_factor: 0
              </div>
              <div id="relative_density_factor_control_input">
                <div class="slider" id="relative_density_factor_slider"></div>
              </div>
            </div>
            <div class="interface_labels">2D point cloud</div>
            <div id="number_of_points_real_plane">
              <div id="number_of_points_real_plane_label">
                number_of_points_real_plane: 10
              </div>
              <div id="number_of_points_real_plane_input">
                <div
                  class="slider"
                  id="number_of_points_real_plane_slider"
                ></div>
              </div>
            </div>
            <div class="interface_labels">Buildings</div>
            <div id="buildings_transparency">
              <div id="buildings_presence_label">Show buildings</div>
              <input type="checkbox" id="buildings_presence_input" checked />
              <div id="buildings_print_presence_label">
                Show buildings print
              </div>
              <input
                type="checkbox"
                id="buildings_print_presence_input"
                checked
              />
              <div id="buildings_transparency_label">
                buildings_transparency: 1
              </div>
              <div id="buildings_transparency_input">
                <div class="slider" id="buildings_transparency_slider"></div>
              </div>
            </div>
            <div id="type_bati_div">
              <select id="type_bati" name="type_bati" form="type_bati">
                <option value="autre" selected>autre</option>
                <option value="lcz_1">Main LCZ type</option>
                <option value="lcz_2">Secondary LCZ type</option>
                <option value="typo_maj">
                  Typologie majoritaire dans l'USR
                </option>
                <option value="typo_second">
                  Typologie secondaire dans l'USR
                </option>
                <option value="build_dens">densité surfacique de bâti</option>
                <option value="hydro_dens">
                  densité surfacique de zone en eau
                </option>
                <option value="veget_dens">
                  densité surfacique de zone de végétation
                </option>
                <option value="road_dens">densité surfacique de route</option>
                <option value="ba">
                  pourcentage de "Bâtiment d'Activité" dans l'USR
                </option>
                <option value="bgh">
                  pourcentage de "Bâtiment de Grande Hauteur" dans l'USR
                </option>
                <option value="icif">
                  pourcentage d' "Immeuble Continu sur Ilôt Fermé" dans l'USR
                </option>
                <option value="icio">
                  pourcentage d' "Immeuble Continu sur Ilôt Ouvert" dans l'USR
                </option>
                <option value="id">
                  pourcentage d' "Immeuble Discontinu" dans l'USR
                </option>
                <option value="local">pourcentage de "Local" dans l'USR</option>
                <option value="pcif">
                  pourcentage de "Pavillon Continu sur Ilôt Fermé" dans l'USR
                </option>
                <option value="pcio">
                  pourcentage de "Pavillon Continu sur Ilôt Ouvert" dans l'USR
                </option>
                <option value="pd">
                  pourcentage de "Pavillon Discontinu" dans l'USR
                </option>
                <option value="psc">
                  pourcentage de "Pavillon Semi-Discontinu" dans l'USR
                </option>
              </select>
            </div>

            <!-- <div id="h_control">
						<div id="h_control_label">h_factor : 1</div>
						<div id="h_control_slider">
							<div class="slider" id="h_slider"></div>
						</div>
					</div>-->
          </div>
          <div
            id="animation_control_label"
            class="general_control_container_div"
          >
            Animation
          </div>
          <div id="animation_control_container">
            <div id="animation_control">
              <div>
                <input
                  type="checkbox"
                  class="animation_ckbx_class"
                  id="animation_ckbx"
                />Animation
              </div>
            </div>
            <div id="animation_type">
              <input
                type="radio"
                id="animation_type_temp"
                name="temp"
                value="temp"
                class="animation_type_checkbox"
                checked
              />
              <label for="animation_type_temp">temp</label>

              <input
                type="radio"
                id="animation_type_z"
                name="z"
                value="z"
                class="animation_type_checkbox"
              />
              <label for="animation_type_z">z</label>

              <input
                type="radio"
                id="animation_type_x"
                name="x"
                value="x"
                class="animation_type_checkbox"
              />
              <label for="animation_type_x">x</label>

              <input
                type="radio"
                id="animation_type_y"
                name="y"
                value="y"
                class="animation_type_checkbox"
              />
              <label for="animation_type_y">y</label>
            </div>
            <div id="animation_speed_control_label">
              animation_speed_factor: 0.01
            </div>
            <div id="animation_speed_control_input">
              <div class="slider" id="animation_speed_slider"></div>
            </div>
          </div>
          <div id="filter_control_label" class="general_control_container_div">
            Filters
          </div>
          <div id="filter_control_container">
            <div id="temp-double-slider">
              <div>
                <input
                  type="checkbox"
                  class="filter_ckbx_class"
                  id="temp_filter_ckbx"
                />Filtering temperature
              </div>
              <p>
                <label for="temperatures">Temperatures :</label>
                <input
                  type="text"
                  id="temperatures-label"
                  readonly
                  style="border: 0; color: #361bd3; font-weight: bold"
                />
              </p>

              <div id="temp-slider-range"></div>
            </div>
            <div id="z-double-slider">
              <div>
                <input
                  type="checkbox"
                  class="filter_ckbx_class"
                  id="z_filter_ckbx"
                />Filtering Z
              </div>
              <p>
                <label for="z-slider">Z control :</label>
                <input
                  type="text"
                  id="z-slider-label"
                  readonly
                  style="border: 0; color: #361bd3; font-weight: bold"
                />
              </p>

              <div id="z-slider-range"></div>
            </div>
            <div id="h-double-slider">
              <div>
                <input
                  type="checkbox"
                  class="filter_ckbx_class"
                  id="h_filter_ckbx"
                />Filtering H
              </div>
              <p>
                <label for="h-slider">H control :</label>
                <input
                  type="text"
                  id="h-slider-label"
                  readonly
                  style="border: 0; color: #361bd3; font-weight: bold"
                />
              </p>

              <div id="h-slider-range"></div>
            </div>
            <div id="x-double-slider">
              <div>
                <input
                  type="checkbox"
                  class="filter_ckbx_class"
                  id="x_filter_ckbx"
                />Filtering X
              </div>
              <p>
                <label for="x-slider">X control :</label>
                <input
                  type="text"
                  id="x-slider-label"
                  readonly
                  style="border: 0; color: #361bd3; font-weight: bold"
                />
              </p>

              <div id="x-slider-range"></div>
            </div>
            <div id="y-double-slider">
              <div>
                <input
                  type="checkbox"
                  class="filter_ckbx_class"
                  id="y_filter_ckbx"
                />Filtering Y
              </div>
              <p>
                <label for="y-slider">Y control :</label>
                <input
                  type="text"
                  id="y-slider-label"
                  readonly
                  style="border: 0; color: #361bd3; font-weight: bold"
                />
              </p>

              <div id="y-slider-range"></div>
            </div>
          </div>
          <div id="choose_params_label" class="general_control_container_div">
            Configuration
          </div>
          <div id="choose_params_container">
            <div class="sauvegarde_params">
              <input
                type="text"
                id="button_file_text"
                placeholder="Nommez votre sauvegarde"
              />
              <input
                type="button"
                id="button_file"
                value="Sauver configuration actuelle"
              />
            </div>
            <div class="sauvegarde_params" id="load_params">
              <div>Charger une configuration :</div>
              <input type="file" id="button_load_file" accept=".txt" />
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Div liste couleur position absolute-->
    <div id="color_list_absolute"></div>

    <script type="x-shader/x-vertex" id="vertexshader_fix_3D_points">
      precision highp float;
      precision mediump sampler3D;
      uniform float x_factor_min;
      uniform float x_factor_max;
      uniform float y_factor_min;
      uniform float y_factor_max;
      uniform float z_factor_min;
      uniform float z_factor_max;
      uniform float h_factor_min;
      uniform float h_factor_max;
      uniform float temp_factor_min;
      uniform float temp_factor_max;
      uniform float regularSize;
      uniform float relativeSizeFactor;
      uniform vec3 u_size;
      uniform vec2 u_clim;
      uniform sampler2D zs_data;
      uniform sampler3D u_data;
      uniform sampler3D meso_limit;
      uniform sampler3D teb_limit;
      uniform float x_min;
      uniform float x_max;
      uniform float y_min;
      uniform float y_max;

      uniform float cst_X;
      uniform float cst_Y;
      uniform float cst_Z;
      uniform float zs;

      uniform bool temp_filter;
      uniform bool z_filter;
      uniform bool h_filter;
      uniform bool x_filter;
      uniform bool y_filter;
      varying float to_discard;

      uniform int active_color_control;


      attribute float x_position;
      attribute float y_position;
      attribute float z_position;
      attribute float h_position;
      attribute float customtransparency;
      attribute float custompercentage;
      attribute float voxel_level;
      varying float voxel_point_level;
      varying vec3 v_position;
      varying vec3 voxel_position;
      varying float transparency;
      varying float tempPercentage;

      varying float voxel_position_z_1;

      varying float temp_val;

      float sample1(vec3 texcoords) {
      	/* Sample float value from a 3D texture. Assumes intensity data. */
      	return texture(u_data, texcoords.xyz).r;
      }

      void main() {
      	v_position = position;

      	float voxel_position_x = ((v_position[0]/cst_X) - x_min)/(x_max - x_min)*u_size[0];
      	float voxel_position_y = u_size[1]-(-(v_position[2]/cst_Y) - y_min)/(y_max - y_min)*u_size[1];
      	float voxel_position_z = 0.0;
      	vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
      	float new_zs = texture2D(zs_data, (voxel_xy/vec2(u_size[0],u_size[1]))).r;

      	voxel_point_level = voxel_level;

      	if(voxel_level < 7.0){

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],7);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,0.0);
      			sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if((sample3D_val)*cst_Z > v_position[1]){
      				voxel_position_z = 0.0;
      			} else {
      				for(int i=1; i< 7; i++){
      					sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      					vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      					sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;
      					float sample3D_val_2 = texture(teb_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      					if((sample3D_val)*cst_Z > v_position[1]){
      						float z_min = sample3D_val;
      						float z_max = sample3D_val_2;
      						voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
      						break;
      					}
      				}
      			}
      		} else {

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],33);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,1.0);
      			sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if(sample3D_val*cst_Z > v_position[1]){
      					voxel_position_z = 6.0;
      				} else {
      					for(int i=2; i< 32; i++){
      						sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      						vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      						sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;
      						float sample3D_val_2 = texture(meso_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      						if(sample3D_val*cst_Z > v_position[1]){
      							float z_min = sample3D_val;
      							float z_max = sample3D_val_2;
      							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0 + 5.0;
      							break;
      						}
      					}
      				}
      		}

      	voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z);

      	voxel_position_z_1 = voxel_position_z;

      	float val = sample1(voxel_position/u_size);
      	temp_val = val;


      	if(active_color_control == 0){
      		tempPercentage = 0.5;
      	} else if(active_color_control == 1){
      		if (val<u_clim[0]) {
      			tempPercentage = 0.0;
      		} else if(val> u_clim[1]) {
      			tempPercentage = 1.0;
      		} else {
      			tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
      			if (tempPercentage < 0.0) {
      				tempPercentage = 0.0;
      			} else if (tempPercentage > 1.0) {
      				tempPercentage = 1.0;
      			}
      		}
      	} else if(active_color_control == 2){
      		tempPercentage = (val - 297.92)/(300.8 - 297.92);
      		if (tempPercentage < 0.0) {
      			tempPercentage = 0.0;
      		} else if (tempPercentage > 1.0) {
      			tempPercentage = 1.0;
      		}
      	}


      	float sizeShader;
      	float addFactor;
      	float basicSize = 10000.0;
      	if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
      		sizeShader = basicSize;
      	} else if (relativeSizeFactor < 1.0) {
      		addFactor = 1.0-relativeSizeFactor;
      		sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize - (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	} else if (relativeSizeFactor > 1.0) {
      		addFactor = relativeSizeFactor - 1.0;
      		sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize + (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	}

      	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

      	to_discard = 0.0;
      	if(temp_filter ==  true){
      		if(tempPercentage < temp_factor_min || tempPercentage > temp_factor_max || val < u_clim[0] ||  val > u_clim[1]){
      			to_discard = 1.0;
      		}
      	}
      	if(z_filter ==  true){
      		if(z_position < z_factor_min || z_position > z_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(h_filter ==  true){
      		if(h_position < h_factor_min || h_position > h_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(x_filter ==  true){
      		if(x_position < x_factor_min || x_position > x_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(y_filter ==  true){
      		if(y_position < y_factor_min || y_position > y_factor_max){
      			to_discard = 1.0;
      		}
      	}


      	//if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
      		gl_PointSize = regularSize* sizeShader * ( 1.0 / -mvPosition.z );
      	//} else {
      	//	gl_PointSize = 0.0;
      	//}

      	transparency = customtransparency;
      	gl_Position = projectionMatrix * mvPosition;



      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader_3D_points">
      precision highp float;
      precision mediump sampler3D;

      uniform sampler2D u_cmdata;
      uniform sampler2D pointTexture;
      uniform vec3 u_size;
      uniform int active_color_control;

      varying vec3 voxel_position;

      varying float voxel_point_level;

      varying float temp_val;

      varying float voxel_position_z_1;

      varying float transparency;
      varying float tempPercentage;

      varying float to_discard;


      void main() {

      	if(to_discard > 0.0){
      		discard;
      	}

      	if(active_color_control == 1){
      		if(tempPercentage == -1.0){
      		gl_FragColor = vec4(0.0,0.0,0.0,0.0);

      		} else{
      			gl_FragColor = texture2D(u_cmdata, vec2(tempPercentage, 0.5));
      		}
      	} else if(active_color_control == 2){
      			float newval;
      			if(temp_val<300.8 && temp_val >= 300.02){
      				newval = 5.5/6.0;
      			} else if(temp_val<300.02 && temp_val >= 299.64){
      				newval = 4.5/6.0;
      			} else if(temp_val<299.64 && temp_val >= 299.36){
      				newval = 3.5/6.0;
      			} else if(temp_val<299.36 && temp_val >= 298.98){
      				newval = 2.5/6.0;
      			} else if(temp_val<298.98 && temp_val >= 298.40){
      				newval = 1.5/6.0;
      			} else if(temp_val<298.40 && temp_val >= 297.92){
      				newval = 0.5/6.0;
      			}
      			gl_FragColor = texture2D(u_cmdata, vec2(newval, 0.5));

      		} else {

      		//float val = fract((float(int(voxel_position[2]))+0.5)/(u_size[2]/7.0));
      		//float val = mod((float(int(voxel_position[2]))+0.5),6.0)/6.0;
      		//float val = mod((voxel_point_level-0.5),6.0)/6.0;
      		float val = (6.0-mod((voxel_point_level-0.5),6.0))/6.0;

      		gl_FragColor = texture2D(u_cmdata, vec2(val, 0.5));

      		//gl_FragColor = vec4(fract(voxel_position[2]),0.0,0.0,1.0);

      	}

      	vec4 texture4 = texture2D( pointTexture, gl_PointCoord );
      	if(texture4.a < 0.8){
      		discard;
      	}

      	gl_FragColor = vec4(gl_FragColor[0],gl_FragColor[1],gl_FragColor[2],transparency);

      	//gl_FragColor = vec4(float(int(voxel_position_z_1))/6.0,0.0,0.0,transparency);


      	gl_FragColor = gl_FragColor * texture4;

      }
    </script>

    <script type="x-shader/x-vertex" id="vertexshader_fix_3D_anim_temp">
      precision highp float;
      precision mediump sampler3D;
      uniform float x_factor_min;
      uniform float x_factor_max;
      uniform float y_factor_min;
      uniform float y_factor_max;
      uniform float z_factor_min;
      uniform float z_factor_max;
      uniform float h_factor_min;
      uniform float h_factor_max;
      uniform float temp_factor_min;
      uniform float temp_factor_max;
      uniform float regularSize;
      uniform float relativeSizeFactor;
      uniform vec3 u_size;
      uniform vec2 u_clim;
      uniform sampler2D zs_data;
      uniform sampler3D u_data;
      uniform float x_min;
      uniform float x_max;
      uniform float y_min;
      uniform float y_max;
      uniform float mesolimit[38];
      uniform float cst_X;
      uniform float cst_Y;
      uniform float cst_Z;
      uniform float zs;
      uniform float u_time;

      uniform bool temp_filter;
      uniform bool z_filter;
      uniform bool h_filter;
      uniform bool x_filter;
      uniform bool y_filter;
      varying float to_discard;

      varying float voxel_point_level;

      uniform sampler3D meso_limit;
      uniform sampler3D teb_limit;

      uniform int active_color_control;

      attribute float x_position;
      attribute float y_position;
      attribute float z_position;
      attribute float h_position;
      attribute float customtransparency;
      attribute float custompercentage;
      attribute float voxel_level;
      varying vec3 voxel_position;
      varying vec3 v_position;
      varying float transparency;
      varying float tempPercentage;

      varying float temp_val;

      float sample1(vec3 texcoords) {
      	/* Sample float value from a 3D texture. Assumes intensity data. */
      	return texture(u_data, texcoords.xyz).r;
      }

      void main() {
      	v_position = position;

      	float voxel_position_x = ((v_position[0]/cst_X) - x_min)/(x_max - x_min)*u_size[0];
      	float voxel_position_y = u_size[1]-(-(v_position[2]/cst_Y) - y_min)/(y_max - y_min)*u_size[1];
      	float voxel_position_z = 0.0;
      	vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
      	float new_zs = texture2D(zs_data, (voxel_xy/vec2(u_size[0],u_size[1]))).r;

      	voxel_point_level = voxel_level;

      	if(voxel_level < 7.0){

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],7);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,0.0);
      			sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if((sample3D_val)*cst_Z > v_position[1]){
      				voxel_position_z = 0.0;
      			} else {
      				for(int i=1; i< 7; i++){
      					sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      					vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      					sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;
      					float sample3D_val_2 = texture(teb_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      					if((sample3D_val)*cst_Z > v_position[1]){
      						float z_min = sample3D_val;
      						float z_max = sample3D_val_2;
      						voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
      						break;
      					}
      				}
      			}
      		} else {

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],33);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,1.0);
      			sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if(sample3D_val*cst_Z > v_position[1]){
      					voxel_position_z = 6.0;
      				} else {
      					for(int i=2; i< 32; i++){
      						sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      						vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      						sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;
      						float sample3D_val_2 = texture(meso_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      						if(sample3D_val*cst_Z > v_position[1]){
      							float z_min = sample3D_val;
      							float z_max = sample3D_val_2;
      							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0 + 5.0;
      							break;
      						}
      					}
      				}
      		}

      	voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z);

      	float val = sample1(voxel_position/u_size);

      	temp_val = val;

      	if(active_color_control == 0){
      		tempPercentage = 0.5;
      	} else if(active_color_control == 1){
      		if (val<u_clim[0] || val> u_clim[1]) {
      			tempPercentage = -1.0;
      		} else {
      			tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
      			if (tempPercentage < 0.0) {
      				tempPercentage = 0.0;
      			} else if (tempPercentage > 1.0) {
      				tempPercentage = 1.0;
      			}
      		}
      	} else if(active_color_control == 2){
      		tempPercentage = (val - 297.92)/(300.8 - 297.92);
      		if (tempPercentage < 0.0) {
      			tempPercentage = 0.0;
      		} else if (tempPercentage > 1.0) {
      			tempPercentage = 1.0;
      		}
      	}

      	float sizeShader;
      	float addFactor;
      	float basicSize = 10000.0;
      	if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
      		sizeShader = basicSize;
      	} else if (relativeSizeFactor < 1.0) {
      		addFactor = 1.0-relativeSizeFactor;
      		sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize - (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	} else if (relativeSizeFactor > 1.0) {
      		addFactor = relativeSizeFactor - 1.0;
      		sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize + (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	}

      	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      	//if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
      	to_discard = 0.0;
      	if(temp_filter ==  true){
      		if(tempPercentage < temp_factor_min || tempPercentage > temp_factor_max || val < u_clim[0] ||  val > u_clim[1]){
      			to_discard = 1.0;
      		}
      	}
      	if(z_filter ==  true){
      		if(z_position < z_factor_min || z_position > z_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(h_filter ==  true){
      		if(h_position < h_factor_min || h_position > h_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(x_filter ==  true){
      		if(x_position < x_factor_min || x_position > x_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(y_filter ==  true){
      		if(y_position < y_factor_min || y_position > y_factor_max){
      			to_discard = 1.0;
      		}
      	}
      			if(abs(sin(u_time + tempPercentage*3.14159265359)) > 0.9){
      				if(abs(sin(u_time + tempPercentage*3.14159265359)) > 0.95){
      					gl_PointSize = regularSize*sizeShader * ( 1.0 / -mvPosition.z );
      				} else {
      					gl_PointSize = ((abs(sin(u_time + tempPercentage*3.14159265359)) - 0.9)/(0.95 - 0.9))*abs(sin(u_time + tempPercentage*3.14159265359))*regularSize*sizeShader * ( 1.0 / -mvPosition.z );
      				}
      			} else {
      				//gl_PointSize = 0.0;
      				to_discard = 1.0;
      			}
      		//} else {
      				//gl_PointSize = 0.0;
      		//}

      	transparency = customtransparency;
      	gl_Position = projectionMatrix * mvPosition;


      }
    </script>

    <script type="x-shader/x-vertex" id="vertexshader_fix_3D_anim_z">
      precision highp float;
      precision mediump sampler3D;
      uniform float x_factor_min;
      uniform float x_factor_max;
      uniform float y_factor_min;
      uniform float y_factor_max;
      uniform float z_factor_min;
      uniform float z_factor_max;
      uniform float h_factor_min;
      uniform float h_factor_max;
      uniform float temp_factor_min;
      uniform float temp_factor_max;
      uniform float regularSize;
      uniform float relativeSizeFactor;
      uniform vec3 u_size;
      uniform vec2 u_clim;
      uniform sampler2D zs_data;
      uniform sampler3D u_data;

      uniform sampler3D meso_limit;
      uniform sampler3D teb_limit;

      uniform bool temp_filter;
      uniform bool z_filter;
      uniform bool h_filter;
      uniform bool x_filter;
      uniform bool y_filter;
      varying float to_discard;

      uniform int active_color_control;

      uniform float x_min;
      uniform float x_max;
      uniform float y_min;
      uniform float y_max;
      uniform float mesolimit[38];
      uniform float cst_X;
      uniform float cst_Y;
      uniform float cst_Z;
      uniform float zs;
      uniform float u_time;
      attribute float x_position;
      attribute float y_position;
      attribute float z_position;
      attribute float h_position;
      attribute float customtransparency;
      attribute float custompercentage;
      attribute float voxel_level;
      varying vec3 voxel_position;
      varying vec3 v_position;
      varying float transparency;
      varying float tempPercentage;

      varying float voxel_point_level;

      varying float temp_val;

      float sample1(vec3 texcoords) {
      	/* Sample float value from a 3D texture. Assumes intensity data. */
      	return texture(u_data, texcoords.xyz).r;
      }

      void main() {

      	v_position = position;
      	float voxel_position_x = ((v_position[0]/cst_X) - x_min)/(x_max - x_min)*u_size[0];
      	float voxel_position_y = u_size[1]-(-(v_position[2]/cst_Y) - y_min)/(y_max - y_min)*u_size[1];
      	float voxel_position_z = 0.0;
      	vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
      	float new_zs = texture2D(zs_data, (voxel_xy/vec2(u_size[0],u_size[1]))).r;
      	voxel_point_level = voxel_level;
      	if(voxel_level < 7.0){

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],7);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,0.0);
      			sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if((sample3D_val)*cst_Z > v_position[1]){
      				voxel_position_z = 0.0;
      			} else {
      				for(int i=1; i< 7; i++){
      					sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      					vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      					sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;
      					float sample3D_val_2 = texture(teb_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      					if((sample3D_val)*cst_Z > v_position[1]){
      						float z_min = sample3D_val;
      						float z_max = sample3D_val_2;
      						voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
      						break;
      					}
      				}
      			}
      		} else {

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],33);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,1.0);
      			sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if(sample3D_val*cst_Z > v_position[1]){
      					voxel_position_z = 6.0;
      				} else {
      					for(int i=2; i< 32; i++){
      						sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      						vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      						sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;
      						float sample3D_val_2 = texture(meso_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      						if(sample3D_val*cst_Z > v_position[1]){
      							float z_min = sample3D_val;
      							float z_max = sample3D_val_2;
      							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0 + 5.0;
      							break;
      						}
      					}
      				}
      		}

      	voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z);

      	float val = sample1(voxel_position/u_size);

      	temp_val = val;

      	if(active_color_control == 0){
      		tempPercentage = 0.5;
      	} else if(active_color_control == 1){
      		if (val<u_clim[0] || val> u_clim[1]) {
      			tempPercentage = -1.0;
      		} else {
      			tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
      			if (tempPercentage < 0.0) {
      				tempPercentage = 0.0;
      			} else if (tempPercentage > 1.0) {
      				tempPercentage = 1.0;
      			}
      		}
      	} else if(active_color_control == 2){
      		tempPercentage = (val - 297.92)/(300.8 - 297.92);
      		if (tempPercentage < 0.0) {
      			tempPercentage = 0.0;
      		} else if (tempPercentage > 1.0) {
      			tempPercentage = 1.0;
      		}
      	}

      	float sizeShader;
      	float addFactor;
      	float basicSize = 10000.0;
      	if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
      		sizeShader = basicSize;
      	} else if (relativeSizeFactor < 1.0) {
      		addFactor = 1.0-relativeSizeFactor;
      		sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize - (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	} else if (relativeSizeFactor > 1.0) {
      		addFactor = relativeSizeFactor - 1.0;
      		sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize + (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	}
      	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      	//if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
      	to_discard = 0.0;
      	if(temp_filter ==  true){
      		if(tempPercentage < temp_factor_min || tempPercentage > temp_factor_max || val < u_clim[0] ||  val > u_clim[1]){
      			to_discard = 1.0;
      		}
      	}
      	if(z_filter ==  true){
      		if(z_position < z_factor_min || z_position > z_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(h_filter ==  true){
      		if(h_position < h_factor_min || h_position > h_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(x_filter ==  true){
      		if(x_position < x_factor_min || x_position > x_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(y_filter ==  true){
      		if(y_position < y_factor_min || y_position > y_factor_max){
      			to_discard = 1.0;
      		}
      	}
      		if(abs(sin(u_time + 3.14159265359*z_position)) > 0.9){
      			if(abs(sin(u_time + 3.14159265359*z_position)) > 0.95){
      				gl_PointSize = regularSize*sizeShader * ( 1.0 / -mvPosition.z );
      			} else {
      				gl_PointSize = ((abs(sin(u_time + 3.14159265359*z_position)) - 0.9)/(0.95 - 0.9))*abs(sin(u_time + 3.14159265359*z_position))*regularSize*sizeShader * ( 1.0 / -mvPosition.z );
      			}
      		} else {
      			to_discard = 1.0;
      		}
      	//} else {
      	//	gl_PointSize = 0.0;
      	//}

      	transparency = customtransparency;
      	gl_Position = projectionMatrix * mvPosition;
      }
    </script>

    <script type="x-shader/x-vertex" id="vertexshader_fix_3D_anim_x">
      precision highp float;
      precision mediump sampler3D;
      uniform float x_factor_min;
      uniform float x_factor_max;
      uniform float y_factor_min;
      uniform float y_factor_max;
      uniform float z_factor_min;
      uniform float z_factor_max;
      uniform float h_factor_min;
      uniform float h_factor_max;
      uniform float temp_factor_min;
      uniform float temp_factor_max;
      uniform float regularSize;
      uniform float relativeSizeFactor;
      uniform vec3 u_size;
      uniform vec2 u_clim;
      uniform sampler2D zs_data;
      uniform sampler3D u_data;

      uniform sampler3D meso_limit;
      uniform sampler3D teb_limit;

      uniform bool temp_filter;
      uniform bool z_filter;
      uniform bool h_filter;
      uniform bool x_filter;
      uniform bool y_filter;
      varying float to_discard;

      uniform int active_color_control;

      varying float voxel_point_level;

      uniform float x_min;
      uniform float x_max;
      uniform float y_min;
      uniform float y_max;
      uniform float mesolimit[38];
      uniform float cst_X;
      uniform float cst_Y;
      uniform float cst_Z;
      uniform float zs;
      uniform float u_time;
      attribute float x_position;
      attribute float y_position;
      attribute float z_position;
      attribute float h_position;
      attribute float customtransparency;
      attribute float custompercentage;
      attribute float voxel_level;
      varying vec3 voxel_position;
      varying vec3 v_position;
      varying float transparency;
      varying float tempPercentage;

      varying float temp_val;

      float sample1(vec3 texcoords) {
      	/* Sample float value from a 3D texture. Assumes intensity data. */
      	return texture(u_data, texcoords.xyz).r;
      }

      void main() {
      	v_position = position;

      	float voxel_position_x = ((v_position[0]/cst_X) - x_min)/(x_max - x_min)*u_size[0];
      	float voxel_position_y = u_size[1]-(-(v_position[2]/cst_Y) - y_min)/(y_max - y_min)*u_size[1];
      	float voxel_position_z = 0.0;
      	vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
      	float new_zs = texture2D(zs_data, (voxel_xy/vec2(u_size[0],u_size[1]))).r;

      	voxel_point_level = voxel_level;
      	if(voxel_level < 7.0){

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],7);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,0.0);
      			sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if((sample3D_val)*cst_Z > v_position[1]){
      				voxel_position_z = 0.0;
      			} else {
      				for(int i=1; i< 7; i++){
      					sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      					vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      					sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;
      					float sample3D_val_2 = texture(teb_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      					if((sample3D_val)*cst_Z > v_position[1]){
      						float z_min = sample3D_val;
      						float z_max = sample3D_val_2;
      						voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
      						break;
      					}
      				}
      			}
      		} else {

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],33);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,1.0);
      			sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if(sample3D_val*cst_Z > v_position[1]){
      					voxel_position_z = 6.0;
      				} else {
      					for(int i=2; i< 32; i++){
      						sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      						vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      						sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;
      						float sample3D_val_2 = texture(meso_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      						if(sample3D_val*cst_Z > v_position[1]){
      							float z_min = sample3D_val;
      							float z_max = sample3D_val_2;
      							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0 + 5.0;
      							break;
      						}
      					}
      				}
      		}

      	voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z);

      	float val = sample1(voxel_position/u_size);

      	temp_val = val;

      	if(active_color_control == 0){
      		tempPercentage = 0.5;
      	} else if(active_color_control == 1){
      		if (val<u_clim[0] || val> u_clim[1]) {
      			tempPercentage = -1.0;
      		} else {
      			tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
      			if (tempPercentage < 0.0) {
      				tempPercentage = 0.0;
      			} else if (tempPercentage > 1.0) {
      				tempPercentage = 1.0;
      			}
      		}
      	} else if(active_color_control == 2){
      		tempPercentage = (val - 297.92)/(300.8 - 297.92);
      		if (tempPercentage < 0.0) {
      			tempPercentage = 0.0;
      		} else if (tempPercentage > 1.0) {
      			tempPercentage = 1.0;
      		}
      	}

      	float sizeShader;
      	float addFactor;
      	float basicSize = 10000.0;
      	if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
      		sizeShader = basicSize;
      	} else if (relativeSizeFactor < 1.0) {
      		addFactor = 1.0-relativeSizeFactor;
      		sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize - (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	} else if (relativeSizeFactor > 1.0) {
      		addFactor = relativeSizeFactor - 1.0;
      		sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize + (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	}

      	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      	//if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
      	to_discard = 0.0;
      	if(temp_filter ==  true){
      		if(tempPercentage < temp_factor_min || tempPercentage > temp_factor_max || val < u_clim[0] ||  val > u_clim[1]){
      			to_discard = 1.0;
      		}
      	}
      	if(z_filter ==  true){
      		if(z_position < z_factor_min || z_position > z_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(h_filter ==  true){
      		if(h_position < h_factor_min || h_position > h_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(x_filter ==  true){
      		if(x_position < x_factor_min || x_position > x_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(y_filter ==  true){
      		if(y_position < y_factor_min || y_position > y_factor_max){
      			to_discard = 1.0;
      		}
      	}
      		if(abs(sin(u_time + 3.14159265359*x_position)) > 0.9){
      			if(abs(sin(u_time + 3.14159265359*x_position)) > 0.95){
      				gl_PointSize = regularSize*sizeShader * ( 1.0 / -mvPosition.z );
      			} else {
      				gl_PointSize = ((abs(sin(u_time + 3.14159265359*x_position)) - 0.9)/(0.95 - 0.9))*abs(sin(u_time + 3.14159265359*x_position))*regularSize*sizeShader * ( 1.0 / -mvPosition.z );
      			}
      		} else {
      			to_discard = 0.0;
      		}
      	//} else {
      	//	gl_PointSize = 0.0;
      	//}

      	transparency = customtransparency;
      	gl_Position = projectionMatrix * mvPosition;
      }
    </script>

    <script type="x-shader/x-vertex" id="vertexshader_fix_3D_anim_y">
      precision highp float;
      precision mediump sampler3D;
      uniform float x_factor_min;
      uniform float x_factor_max;
      uniform float y_factor_min;
      uniform float y_factor_max;
      uniform float z_factor_min;
      uniform float z_factor_max;
      uniform float h_factor_min;
      uniform float h_factor_max;
      uniform float temp_factor_min;
      uniform float temp_factor_max;
      uniform float regularSize;
      uniform float relativeSizeFactor;
      uniform vec3 u_size;
      uniform vec2 u_clim;
      uniform sampler2D zs_data;
      uniform sampler3D u_data;

      uniform bool temp_filter;
      uniform bool z_filter;
      uniform bool h_filter;
      uniform bool x_filter;
      uniform bool y_filter;
      varying float to_discard;

      uniform sampler3D meso_limit;
      uniform sampler3D teb_limit;

      uniform int active_color_control;

      uniform float x_min;
      uniform float x_max;
      uniform float y_min;
      uniform float y_max;
      uniform float mesolimit[38];
      uniform float cst_X;
      uniform float cst_Y;
      uniform float cst_Z;
      uniform float zs;
      uniform float u_time;
      attribute float x_position;
      attribute float y_position;
      attribute float z_position;
      attribute float h_position;
      attribute float customtransparency;
      attribute float custompercentage;
      attribute float voxel_level;
      varying vec3 voxel_position;
      varying vec3 v_position;
      varying float transparency;
      varying float tempPercentage;

      varying float temp_val;

      float sample1(vec3 texcoords) {
      	/* Sample float value from a 3D texture. Assumes intensity data. */
      	return texture(u_data, texcoords.xyz).r;
      }

      void main() {
      	v_position = position;

      	float voxel_position_x = ((v_position[0]/cst_X) - x_min)/(x_max - x_min)*u_size[0];
      	float voxel_position_y = u_size[1]-(-(v_position[2]/cst_Y) - y_min)/(y_max - y_min)*u_size[1];
      	float voxel_position_z = 0.0;
      	vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);
      	float new_zs = texture2D(zs_data, (voxel_xy/vec2(u_size[0],u_size[1]))).r;
      	if(voxel_level < 7.0){

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],7);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,0.0);
      			sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if((sample3D_val)*cst_Z > v_position[1]){
      				voxel_position_z = 0.0;
      			} else {
      				for(int i=1; i< 7; i++){
      					sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      					vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      					sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;
      					float sample3D_val_2 = texture(teb_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      					if((sample3D_val)*cst_Z > v_position[1]){
      						float z_min = sample3D_val;
      						float z_max = sample3D_val_2;
      						voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
      						break;
      					}
      				}
      			}
      		} else {

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],33);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,1.0);
      			sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if(sample3D_val*cst_Z > v_position[1]){
      					voxel_position_z = 6.0;
      				} else {
      					for(int i=2; i< 32; i++){
      						sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      						vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      						sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;
      						float sample3D_val_2 = texture(meso_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      						if(sample3D_val*cst_Z > v_position[1]){
      							float z_min = sample3D_val;
      							float z_max = sample3D_val_2;
      							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0 + 5.0;
      							break;
      						}
      					}
      				}
      		}

      	voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z);

      	float val = sample1(voxel_position/u_size);

      	temp_val = val;

      	if(active_color_control == 0){
      		tempPercentage = 0.5;
      	} else if(active_color_control == 1){
      		if (val<u_clim[0] || val> u_clim[1]) {
      			tempPercentage = -1.0;
      		} else {
      			tempPercentage = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
      			if (tempPercentage < 0.0) {
      				tempPercentage = 0.0;
      			} else if (tempPercentage > 1.0) {
      				tempPercentage = 1.0;
      			}
      		}
      	} else if(active_color_control == 2){
      		tempPercentage = (val - 297.92)/(300.8 - 297.92);
      		if (tempPercentage < 0.0) {
      			tempPercentage = 0.0;
      		} else if (tempPercentage > 1.0) {
      			tempPercentage = 1.0;
      		}
      	}

      	float sizeShader;
      	float addFactor;
      	float basicSize = 10000.0;
      	if (tempPercentage == 0.5 || relativeSizeFactor == 1.0) {
      		sizeShader = basicSize;
      	} else if (relativeSizeFactor < 1.0) {
      		addFactor = 1.0-relativeSizeFactor;
      		sizeShader = (tempPercentage < 0.5) ? basicSize + (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize - (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	} else if (relativeSizeFactor > 1.0) {
      		addFactor = relativeSizeFactor - 1.0;
      		sizeShader = (tempPercentage < 0.5) ? basicSize - (basicSize*addFactor*(0.5*(0.5-tempPercentage))*2.0) : basicSize + (basicSize*addFactor*(0.5*(tempPercentage-0.5))*2.0) ;
      	}

      	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      	//if(custompercentage > temp_factor_min && custompercentage < temp_factor_max && x_position > x_factor_min && x_position < x_factor_max && y_position > y_factor_min && y_position < y_factor_max && z_position > z_factor_min && z_position < z_factor_max && h_position > h_factor_min && h_position < h_factor_max){
      	to_discard = 0.0;
      	if(temp_filter ==  true){
      		if(tempPercentage < temp_factor_min || tempPercentage > temp_factor_max || val < u_clim[0] ||  val > u_clim[1]){
      			to_discard = 1.0;
      		}
      	}
      	if(z_filter ==  true){
      		if(z_position < z_factor_min || z_position > z_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(h_filter ==  true){
      		if(h_position < h_factor_min || h_position > h_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(x_filter ==  true){
      		if(x_position < x_factor_min || x_position > x_factor_max){
      			to_discard = 1.0;
      		}
      	}
      	if(y_filter ==  true){
      		if(y_position < y_factor_min || y_position > y_factor_max){
      			to_discard = 1.0;
      		}
      	}
      		if(abs(sin(u_time + 3.14159265359*y_position)) > 0.9){
      			if(abs(sin(u_time + 3.14159265359*y_position)) > 0.95){
      				gl_PointSize = regularSize*sizeShader * ( 1.0 / -mvPosition.z );
      			} else {
      				gl_PointSize = ((abs(sin(u_time + 3.14159265359*y_position)) - 0.9)/(0.95 - 0.9))*abs(sin(u_time + 3.14159265359*y_position))*regularSize*sizeShader * ( 1.0 / -mvPosition.z );
      			}
      		} else {
      			to_discard = 0.0;
      		}
      	//} else {
      	//	gl_PointSize = 0.0;
      	//}

      	transparency = customtransparency;
      	gl_Position = projectionMatrix * mvPosition;
      }
    </script>

    <script type="x-shader/x-vertex" id="vertexshader_2D_plane">
      varying vec3 v_position;
      attribute float voxel_level;

      uniform bool temp_filter;
      uniform bool z_filter;
      uniform bool h_filter;
      uniform bool x_filter;
      uniform bool y_filter;
      varying float to_discard;

      varying float voxel_point_level;

      void main() {

      	voxel_point_level = voxel_level;

      	vec4 position4 = modelMatrix * vec4(position, 1.);
      	v_position = position4.xyz;
      	gl_Position = projectionMatrix * viewMatrix * position4;
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader_2D_plane">
      precision highp float;
      precision mediump sampler3D;

      varying vec3 v_position;
      uniform vec3 u_size;
      uniform vec2 u_clim;
      uniform sampler3D u_data;
      uniform sampler2D zs_data;
      uniform sampler2D u_cmdata;
      uniform sampler2D pointTexture;

      varying float to_discard;

      uniform sampler3D meso_limit;
      uniform sampler3D teb_limit;

      varying float voxel_point_level;

      uniform float x_min;
      uniform float x_max;
      uniform float y_min;
      uniform float y_max;
      uniform float mesolimit[38];
      uniform float cst_X;
      uniform float cst_Y;
      uniform float cst_Z;
      uniform float zs;
      uniform float transparency_factor;

      uniform int active_color_control;


      float sample1(vec3 texcoords) {
      		/* Sample float value from a 3D texture. Assumes intensity data. */
      		return texture(u_data, texcoords.xyz).r;
      }



      void main() {

      		float voxel_position_x = ((v_position[0]/cst_X) - x_min)/(x_max - x_min)*u_size[0];
      		float voxel_position_y = u_size[1]-(-(v_position[2]/cst_Y) - y_min)/(y_max - y_min)*u_size[1];
      		float voxel_position_z = 0.0;
      		vec2 voxel_xy = vec2(voxel_position_x,voxel_position_y);


      		if(voxel_point_level < 7.0){

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],7);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,0.0);
      			sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if((sample3D_val)*cst_Z > v_position[1]){
      				voxel_position_z = 0.0;
      			} else {
      				for(int i=1; i< 7; i++){
      					sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      					vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      					sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;
      					float sample3D_val_2 = texture(teb_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      					if((sample3D_val)*cst_Z > v_position[1]){
      						float z_min = sample3D_val;
      						float z_max = sample3D_val_2;
      						voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
      						break;
      					}
      				}
      			}
      		} else {

      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;

      			sample3D_size = vec3(u_size[0],u_size[1],33);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,0.0);
      			sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;

      			if(sample3D_val*cst_Z > v_position[1]){
      					voxel_position_z = 6.0;
      				} else {
      					for(int i=1; i< 32; i++){
      						sample3D_coord = vec3(voxel_position_x,voxel_position_y,float(i));
      						vec3 sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      						sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;
      						float sample3D_val_2 = texture(meso_limit, (sample3D_coord_2/sample3D_size).xyz).r;
      						if(sample3D_val*cst_Z > v_position[1]){
      							float z_min = sample3D_val;
      							float z_max = sample3D_val_2;
      							voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0 + 5.0;
      							break;
      						}
      					}
      				}
      		}

      		vec3 voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z);

      		if(active_color_control == 1){
      			float val = sample1(voxel_position/u_size);
      			if(val<u_clim[0]){
      				//gl_FragColor = vec4(0.0,0.0,0.0,0.0);
      				float new_val = 0.0;
      				gl_FragColor = texture2D(u_cmdata, vec2(new_val, 0.5));
      			} else if(val>u_clim[1]){
      				//gl_FragColor = vec4(0.0,0.0,0.0,0.0);
      				float new_val = 1.0;
      				gl_FragColor = texture2D(u_cmdata, vec2(new_val, 0.5));
      			} else{
      				float new_val = (val - u_clim[0])/(u_clim[1] - u_clim[0]);
      				gl_FragColor = texture2D(u_cmdata, vec2(new_val, 0.5));
      			}
      		} else if(active_color_control == 2){
      			float val = sample1(voxel_position/u_size);
      			float newval;
      			if(val<300.8 && val >= 300.02){
      				newval = 5.5/6.0;
      			} else if(val<300.02 && val >= 299.64){
      				newval = 4.5/6.0;
      			} else if(val<299.64 && val >= 299.36){
      				newval = 3.5/6.0;
      			} else if(val<299.36 && val >= 298.98){
      				newval = 2.5/6.0;
      			} else if(val<298.98 && val >= 298.40){
      				newval = 1.5/6.0;
      			} else if(val<298.40 && val >= 297.92){
      				newval = 0.5/6.0;
      			}
      			gl_FragColor = texture2D(u_cmdata, vec2(newval, 0.5));

      		} else {
      			//float val = fract(float(int(voxel_position[2]))/(u_size[2]/7.0));
      			//float val = mod((float(int(voxel_position[2]))+0.5),6.0)/6.0;
      			float val = (6.0-mod((float(int(voxel_position[2]))+0.5),6.0))/6.0;
      			gl_FragColor = texture2D(u_cmdata, vec2(val, 0.5));
      		}

      		gl_FragColor= vec4(gl_FragColor[0],gl_FragColor[1],gl_FragColor[2],transparency_factor);




      }
    </script>

    <script type="x-shader/x-vertex" id="vertexshader_buildings">

      attribute vec3 color;
      attribute vec3 customNormal;
      varying vec3 v_position;
      varying vec3 v_color;
      varying vec3 Normal;

      void main() {
      	vec4 position4 = modelMatrix * vec4(position, 1.);
      	v_position = position4.xyz;
      	v_color = color;
      	Normal = customNormal;

      	gl_Position = projectionMatrix * viewMatrix * position4;

      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader_buildings">
      precision highp float;

      varying vec3 v_position;
      varying vec3 v_color;
      varying vec3 Normal;

      uniform vec3 light_direction[2];
      uniform float light_ambient;

      uniform float transparency;

      void main() {
      	float d = light_ambient;
      	d += max(0.0,dot(Normal,light_direction[0]));
      	d += max(0.0,dot(Normal,light_direction[1]));
      	gl_FragColor= vec4(d * v_color,transparency);
      }
    </script>

    <script type="x-shader/x-vertex" id="vertexshader_3D_plane">
      varying vec3 v_position;
      attribute vec3 customNormal;
      varying vec3 Normal;

      void main() {
      	vec4 position4 = modelMatrix * vec4(position, 1.);
      	v_position = position4.xyz;
      	Normal = customNormal;
      	gl_Position = projectionMatrix * viewMatrix * position4;
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader_3D_plane">
      precision highp float;
      precision mediump sampler3D;

      // position renvoyé par le vertex shader
      varying vec3 v_position;

      // valeurs de températures correspondant aux bornes sélectionnées dans l'histogramme
      uniform vec2 u_clim;
      // dimension du cube 3D de valeurs de température envoyé en datatexture3D
      uniform vec3 u_size;
      // datatexture 3D contenant les valeurs de température
      uniform sampler3D u_data;
      // datatexture 2D contenant l'image utilisée pour déterminer la couleur des objets 3D
      uniform sampler2D u_cmdata;

	  // datatexture 3D contenant les coordonnées xyz des centres des cellules teb
      uniform sampler3D x_center_teb;
	  uniform sampler3D y_center_teb;
	  uniform sampler3D z_center_teb;

      // gestion de la lumière dans la scène 3D
      uniform vec3 light_direction[2];
      uniform float light_ambient;

      // datatexture 3D contenant les altitudes des limites de chaque cellule meso-nh et teb pour chaque xyz
      uniform sampler3D meso_limit;
      uniform sampler3D teb_limit;

      // extent des données de température, utilisées pour trouver les valeurs correspondant à v_position dans les datatexture
      uniform float x_min;
      uniform float x_max;
      uniform float y_min;
      uniform float y_max;
      // valeur entre 0 et 1 indiquant si les données à représenter correspondent aux niveaux teb (0) ou meso-nh (1)
      uniform float type_model;
      // constantes graphiques utilisées dans la scène 3D
      uniform float cst_X;
      uniform float cst_Y;
      uniform float cst_Z;
      //ancienne valeur de zs, uniforme, non utilisée depuis
      uniform float zs;
      //valeur indiquant le type d'échelle de couleur utilisé
      uniform int active_color_control;
	  uniform int plane_type_control;

      uniform float transparency;

      varying vec3 Normal;

      // tableau indiquant pour chaque niveau teb ou meso-nh si le niveau est représenté ou non
      uniform bool sbl_meso_level[37];

      //fonction fournissant une valeur de température contenue dans le cube de température 3D à partir d'une coordonnée exprimée en voxels
      float sample1(vec3 texcoords) {
      		/* Sample float value from a 3D texture. Assumes intensity data. */

      		return texture(u_data, texcoords.xyz).r;
      }

	  vec3 check_text_coord(vec3 texcoords){
			float x_coord;
			float y_coord;
			float z_coord;
			if(texcoords[0]<0.0){
				x_coord = 0.0;
			} else if(texcoords[0]>float(u_size[0])){
				x_coord = float(u_size[0]);
			} else {
				x_coord = texcoords[0];
			}
			if(texcoords[1]<0.0){
				y_coord = 0.0;
			} else if(texcoords[1]>float(u_size[1])){
				y_coord = float(u_size[1]);
			} else {
				y_coord = texcoords[1];
			}
			if(texcoords[2]<0.0){
				z_coord = 0.0;
			} else if(texcoords[2]>6.0){
				z_coord = 5.5;
			} else {
				z_coord = texcoords[2];
			}
			return vec3(x_coord,y_coord,z_coord);
	  }

	  float sample_x(vec3 texcoords) {
      		// Sample float value from a 3D texture. Assumes intensity data.
      		return texture(x_center_teb, texcoords.xyz).r;
      }

	  float sample_y(vec3 texcoords) {
      		// Sample float value from a 3D texture. Assumes intensity data.
      		return texture(y_center_teb, texcoords.xyz).r;
      }

	  float sample_z(vec3 texcoords) {
      		// Sample float value from a 3D texture. Assumes intensity data.
      		return texture(z_center_teb, texcoords.xyz).r;
      }

	  float average_sample(vec3 voxel_position){
		//On cherche maintenant les points les plus proches (9 normalement, 4 au niveau des coins, 6 au niveau des bords)
		int indiceI = 0;
		int indiceJ = 0;
		int indiceZ = 0;
		float res;
		float dist;
		float somme1 = 0.0;
		float somme2 = 0.0;

		float indiceIf;
		float indiceJf;
		float indiceZf;

		for (int i = -1; i <= 1; i++) {
			indiceI = int(voxel_position[0]) + i;
			//bordure en X : si on est au bord ouest ou est
			if (indiceI >= 0 && indiceI < int(u_size[0])){
				for (int j = -1; j <= 1; j++) {
					indiceJ = int(voxel_position[1]) + j;
					//bordure en Y : si on est au bord sud ou nord
					if (indiceJ >= 0 && indiceJ < int(u_size[1])){
						for (int z=-1; z<=1 ;z++ ){
							indiceZ = int(voxel_position[2]) + z;
							if (indiceZ >=0 && indiceZ < int(u_size[2])){
								vec3 pos_bloc_actuel = vec3(indiceI,indiceJ,indiceZ);

								res = sample1(pos_bloc_actuel/u_size);
								indiceIf = float(indiceI);
								indiceJf = float(indiceJ);
								indiceZf = float(indiceZ);

								dist = sqrt((indiceIf - voxel_position[0])*(indiceIf - voxel_position[0])
								+ (indiceJf - voxel_position[1])*(indiceJf - voxel_position[1])
								+ (indiceZf - voxel_position[2])*(indiceZf - voxel_position[2]));

								somme1 = somme1 + res/dist;
								somme2 = somme2 + 1.0/dist;
							}
						}
					}
				}
			}
		}
		return somme1/somme2;
	  }


	  float average_sample_2(vec3 voxel_position, vec3 xyz_position){
		//On cherche maintenant les points les plus proches (4 au niveau des coins)

		//trouver les coordonnées voxel des 8 centres TEB correspondant, en vérifier dans quel partie du voxel est le point correspondant avec les tests suivants, et en verifiant qu'on est pas déjà au bord de la grille
		//=> du coup, peu-être ne pas faire de test sur (voxel_position[1] - float(int(voxel_position[1])))==0.5, si on est vraiment au milieu, soit on prend pas 8 points, mais 4 et on fait de la 2D, soit on tranche et on prend celui du bas/à gauche/devant
		//prendre les positions correspondantes depuis x_center_teb, y_center_teb, z_center_teb avec les coordonnées voxel des 8 centres TEB définis plus tôt
		//calculer la position du points avec xyz_position et cst_X, cst_Y, cst_Z
		//calculer la température en interpolant les température rattachées aux 8 points
		//d'abord faire un calcul de la moyenne (pondérée en fonction de la distance des 2 points au plan où est le point) en Z sur chacun des 4 segments verticaux, puis la même en y, puis la même en x

		// IMPORTANT: est ce que le point correspondant sera bien au milieu des 8 points définis, car c'est quand même pas des polyedre regulier..
		//est ce que on prendra pas du coup 27 points autour? (quoique on a peut être encore le même problème).

		vec3 voxel_1; //coin gauche devant dessous
		vec3 voxel_2; //coin gauche derriere dessous
		vec3 voxel_3; //coin droit derriere dessous
		vec3 voxel_4; //coin droit devant dessous
		vec3 voxel_5; //coin gauche devant dessus
		vec3 voxel_6; //coin gauche derriere dessus
		vec3 voxel_7; //coin droit derriere dessus
		vec3 voxel_8; //coin droit devant dessus

		if(fract(voxel_position[0])<0.5){
			//X partie gauche voxel
			if(fract(voxel_position[1])<0.5){
				//Y partie devant voxel
				if(fract(voxel_position[2])<0.5){
					//Z partie dessous voxel
					//partie du voxel à gauche devant dessous
					voxel_1 = vec3(voxel_position[0]-1.0,voxel_position[1]-1.0,voxel_position[2]-1.0);
					voxel_2 = vec3(voxel_position[0]-1.0,voxel_position[1],voxel_position[2]-1.0);
					voxel_3 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]-1.0);
					voxel_4 = vec3(voxel_position[0],voxel_position[1]-1.0,voxel_position[2]-1.0);
					voxel_5 = vec3(voxel_position[0]-1.0,voxel_position[1]-1.0,voxel_position[2]);
					voxel_6 = vec3(voxel_position[0]-1.0,voxel_position[1],voxel_position[2]);
					voxel_7 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]);
					voxel_8 = vec3(voxel_position[0],voxel_position[1]-1.0,voxel_position[2]);
				} else {
					//Z partie dessus voxel
					//partie du voxel à gauche devant dessus
					voxel_1 = vec3(voxel_position[0]-1.0,voxel_position[1]-1.0,voxel_position[2]);
					voxel_2 = vec3(voxel_position[0]-1.0,voxel_position[1],voxel_position[2]);
					voxel_3 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]);
					voxel_4 = vec3(voxel_position[0],voxel_position[1]-1.0,voxel_position[2]);
					voxel_5 = vec3(voxel_position[0]-1.0,voxel_position[1]-1.0,voxel_position[2]+1.0);
					voxel_6 = vec3(voxel_position[0]-1.0,voxel_position[1],voxel_position[2]+1.0);
					voxel_7 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]+1.0);
					voxel_8 = vec3(voxel_position[0],voxel_position[1]-1.0,voxel_position[2]+1.0);
				}
			} else {
				//Y partie derrière voxel
				if(fract(voxel_position[2])<0.5){
					//Z partie dessous voxel
					//partie du voxel à gauche derriere dessous
					voxel_1 = vec3(voxel_position[0]-1.0,voxel_position[1],voxel_position[2]-1.0);
					voxel_2 = vec3(voxel_position[0]-1.0,voxel_position[1]+1.0,voxel_position[2]-1.0);
					voxel_3 = vec3(voxel_position[0],voxel_position[1]+1.0,voxel_position[2]-1.0);
					voxel_4 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]-1.0);
					voxel_5 = vec3(voxel_position[0]-1.0,voxel_position[1],voxel_position[2]);
					voxel_6 = vec3(voxel_position[0]-1.0,voxel_position[1]+1.0,voxel_position[2]);
					voxel_7 = vec3(voxel_position[0],voxel_position[1]+1.0,voxel_position[2]);
					voxel_8 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]);
				} else {
					//Z partie dessus voxel
					//partie du voxel à gauche derriere dessus
					voxel_1 = vec3(voxel_position[0]-1.0,voxel_position[1],voxel_position[2]);
					voxel_2 = vec3(voxel_position[0]-1.0,voxel_position[1]+1.0,voxel_position[2]);
					voxel_3 = vec3(voxel_position[0],voxel_position[1]+1.0,voxel_position[2]);
					voxel_4 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]);
					voxel_5 = vec3(voxel_position[0]-1.0,voxel_position[1],voxel_position[2]+1.0);
					voxel_6 = vec3(voxel_position[0]-1.0,voxel_position[1]+1.0,voxel_position[2]+1.0);
					voxel_7 = vec3(voxel_position[0],voxel_position[1]+1.0,voxel_position[2]+1.0);
					voxel_8 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]+1.0);
				}
			}
		} else {
			//X partie droite voxel
			if(fract(voxel_position[1])<0.5){
				//Y partie devant voxel
				if(fract(voxel_position[2])<0.5){
					//Z partie dessous voxel
					//partie du voxel à droite devant dessous
					voxel_1 = vec3(voxel_position[0],voxel_position[1]-1.0,voxel_position[2]-1.0);
					voxel_2 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]-1.0);
					voxel_3 = vec3(voxel_position[0]+1.0,voxel_position[1],voxel_position[2]-1.0);
					voxel_4 = vec3(voxel_position[0]+1.0,voxel_position[1]-1.0,voxel_position[2]-1.0);
					voxel_5 = vec3(voxel_position[0],voxel_position[1]-1.0,voxel_position[2]);
					voxel_6 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]);
					voxel_7 = vec3(voxel_position[0]+1.0,voxel_position[1],voxel_position[2]);
					voxel_8 = vec3(voxel_position[0]+1.0,voxel_position[1]-1.0,voxel_position[2]);
				} else {
					//Z partie dessus voxel
					//partie du voxel à droite devant dessus
					voxel_1 = vec3(voxel_position[0],voxel_position[1]-1.0,voxel_position[2]);
					voxel_2 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]);
					voxel_3 = vec3(voxel_position[0]+1.0,voxel_position[1],voxel_position[2]);
					voxel_4 = vec3(voxel_position[0]+1.0,voxel_position[1]-1.0,voxel_position[2]);
					voxel_5 = vec3(voxel_position[0],voxel_position[1]-1.0,voxel_position[2]+1.0);
					voxel_6 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]+1.0);
					voxel_7 = vec3(voxel_position[0]+1.0,voxel_position[1],voxel_position[2]+1.0);
					voxel_8 = vec3(voxel_position[0]+1.0,voxel_position[1]-1.0,voxel_position[2]+1.0);
				}
			} else {
				//Y partie derrière voxel
				if(fract(voxel_position[2])<0.5){
					//Z partie dessous voxel
					//partie du voxel à droite derriere dessous
					voxel_1 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]-1.0);
					voxel_2 = vec3(voxel_position[0],voxel_position[1]+1.0,voxel_position[2]-1.0);
					voxel_3 = vec3(voxel_position[0]+1.0,voxel_position[1]+1.0,voxel_position[2]-1.0);
					voxel_4 = vec3(voxel_position[0]+1.0,voxel_position[1],voxel_position[2]-1.0);
					voxel_5 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]);
					voxel_6 = vec3(voxel_position[0],voxel_position[1]+1.0,voxel_position[2]);
					voxel_7 = vec3(voxel_position[0]+1.0,voxel_position[1]+1.0,voxel_position[2]);
					voxel_8 = vec3(voxel_position[0]+1.0,voxel_position[1],voxel_position[2]);
				} else {
					//Z partie dessus voxel
					//partie du voxel à droite derriere dessus
					voxel_1 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]);
					voxel_2 = vec3(voxel_position[0],voxel_position[1]+1.0,voxel_position[2]);
					voxel_3 = vec3(voxel_position[0]+1.0,voxel_position[1]+1.0,voxel_position[2]);
					voxel_4 = vec3(voxel_position[0]+1.0,voxel_position[1],voxel_position[2]);
					voxel_5 = vec3(voxel_position[0],voxel_position[1],voxel_position[2]+1.0);
					voxel_6 = vec3(voxel_position[0],voxel_position[1]+1.0,voxel_position[2]+1.0);
					voxel_7 = vec3(voxel_position[0]+1.0,voxel_position[1]+1.0,voxel_position[2]+1.0);
					voxel_8 = vec3(voxel_position[0]+1.0,voxel_position[1],voxel_position[2]+1.0);
				}
			}
		}

		vec3 xyz_1 = vec3(sample_x(check_text_coord(voxel_1)/vec3(u_size[0],u_size[1],6.0)),sample_y(check_text_coord(voxel_1)/vec3(u_size[0],u_size[1],6.0)),sample_z(check_text_coord(voxel_1)/vec3(u_size[0],u_size[1],6.0))); //coin gauche devant dessous
		vec3 xyz_2 = vec3(sample_x(check_text_coord(voxel_2)/vec3(u_size[0],u_size[1],6.0)),sample_y(check_text_coord(voxel_2)/vec3(u_size[0],u_size[1],6.0)),sample_z(check_text_coord(voxel_2)/vec3(u_size[0],u_size[1],6.0))); //coin gauche derriere dessous
		vec3 xyz_3 = vec3(sample_x(check_text_coord(voxel_3)/vec3(u_size[0],u_size[1],6.0)),sample_y(check_text_coord(voxel_3)/vec3(u_size[0],u_size[1],6.0)),sample_z(check_text_coord(voxel_3)/vec3(u_size[0],u_size[1],6.0))); //coin droit derriere dessous
		vec3 xyz_4 = vec3(sample_x(check_text_coord(voxel_4)/vec3(u_size[0],u_size[1],6.0)),sample_y(check_text_coord(voxel_4)/vec3(u_size[0],u_size[1],6.0)),sample_z(check_text_coord(voxel_4)/vec3(u_size[0],u_size[1],6.0))); //coin droit devant dessous
		vec3 xyz_5 = vec3(sample_x(check_text_coord(voxel_5)/vec3(u_size[0],u_size[1],6.0)),sample_y(check_text_coord(voxel_5)/vec3(u_size[0],u_size[1],6.0)),sample_z(check_text_coord(voxel_5)/vec3(u_size[0],u_size[1],6.0))); //coin gauche devant dessus
		vec3 xyz_6 = vec3(sample_x(check_text_coord(voxel_6)/vec3(u_size[0],u_size[1],6.0)),sample_y(check_text_coord(voxel_6)/vec3(u_size[0],u_size[1],6.0)),sample_z(check_text_coord(voxel_6)/vec3(u_size[0],u_size[1],6.0))); //coin gauche derriere dessus
		vec3 xyz_7 = vec3(sample_x(check_text_coord(voxel_7)/vec3(u_size[0],u_size[1],6.0)),sample_y(check_text_coord(voxel_7)/vec3(u_size[0],u_size[1],6.0)),sample_z(check_text_coord(voxel_7)/vec3(u_size[0],u_size[1],6.0))); //coin droit derriere dessus
		vec3 xyz_8 = vec3(sample_x(check_text_coord(voxel_8)/vec3(u_size[0],u_size[1],6.0)),sample_y(check_text_coord(voxel_8)/vec3(u_size[0],u_size[1],6.0)),sample_z(check_text_coord(voxel_8)/vec3(u_size[0],u_size[1],6.0))); //coin droit devant dessus

		float temp_1 = sample1(check_text_coord(voxel_1)/u_size);//temperature coin gauche devant dessous
		float temp_2 = sample1(check_text_coord(voxel_2)/u_size);//temperature coin gauche derriere dessous
		float temp_3 = sample1(check_text_coord(voxel_3)/u_size);//temperature coin droit derriere dessous
		float temp_4 = sample1(check_text_coord(voxel_4)/u_size);//temperature coin droit devant dessous
		float temp_5 = sample1(check_text_coord(voxel_5)/u_size);//temperature coin gauche devant dessus
		float temp_6 = sample1(check_text_coord(voxel_6)/u_size);//temperature coin gauche derriere dessus
		float temp_7 = sample1(check_text_coord(voxel_7)/u_size);//temperature coin droit derriere dessus
		float temp_8 = sample1(check_text_coord(voxel_8)/u_size);//temperature coin droit devant dessus

		vec3 xyz_point = vec3(xyz_position[0]/cst_X,xyz_position[2]/cst_Y,xyz_position[1]/cst_Z); //coordonnées du point considéré


		//moyenne sur Z
		float temp_15;
		float temp_26;
		float temp_37;
		float temp_48;
		if(xyz_1[2] == xyz_5[2]){
			temp_15 = temp_1;
		} else {
			float poids_1 = (sqrt((xyz_point[2]-xyz_1[2])*(xyz_point[2]-xyz_1[2]))/sqrt((xyz_5[2]-xyz_1[2])*(xyz_5[2]-xyz_1[2])));
			float poids_5 = (sqrt((xyz_point[2]-xyz_5[2])*(xyz_point[2]-xyz_5[2]))/sqrt((xyz_5[2]-xyz_1[2])*(xyz_5[2]-xyz_1[2])));
			temp_15 = (poids_1*temp_1 + poids_5*temp_5)/(poids_1+poids_5);
		}
		if(xyz_2[2] == xyz_6[2]){
			temp_26 = temp_2;
		} else {
			float poids_2 = (sqrt((xyz_point[2]-xyz_2[2])*(xyz_point[2]-xyz_2[2]))/sqrt((xyz_6[2]-xyz_2[2])*(xyz_6[2]-xyz_2[2])));
			float poids_6 = (sqrt((xyz_point[2]-xyz_6[2])*(xyz_point[2]-xyz_6[2]))/sqrt((xyz_6[2]-xyz_2[2])*(xyz_6[2]-xyz_2[2])));
			temp_26 = (poids_2*temp_2 + poids_6*temp_5)/(poids_2+poids_6);
		}
		if(xyz_3[2] == xyz_7[2]){
			temp_37 = temp_3;
		} else {
			float poids_3 = (sqrt((xyz_point[2]-xyz_3[2])*(xyz_point[2]-xyz_3[2]))/sqrt((xyz_7[2]-xyz_3[2])*(xyz_7[2]-xyz_3[2])));
			float poids_7 = (sqrt((xyz_point[2]-xyz_7[2])*(xyz_point[2]-xyz_7[2]))/sqrt((xyz_7[2]-xyz_3[2])*(xyz_7[2]-xyz_3[2])));
			temp_37 = (poids_3*temp_3 + poids_7*temp_7)/(poids_3+poids_7);
		}
		if(xyz_4[2] == xyz_8[2]){
			temp_48 = temp_1;
		} else {
			float poids_4 = (sqrt((xyz_point[2]-xyz_4[2])*(xyz_point[2]-xyz_4[2]))/sqrt((xyz_8[2]-xyz_4[2])*(xyz_8[2]-xyz_4[2])));
			float poids_8 = (sqrt((xyz_point[2]-xyz_8[2])*(xyz_point[2]-xyz_8[2]))/sqrt((xyz_8[2]-xyz_4[2])*(xyz_8[2]-xyz_4[2])));
			temp_48 = (poids_4*temp_4 + poids_8*temp_8)/(poids_4+poids_8);
		}

		//moyenne sur Y
		float temp_1526;
		float temp_3748;
		if(xyz_1[1] == xyz_2[1]){
			temp_1526 = temp_15;
		} else {
			float poids_15 = (sqrt((xyz_point[1]-xyz_1[1])*(xyz_point[1]-xyz_1[1]))/sqrt((xyz_1[1]-xyz_2[1])*(xyz_1[1]-xyz_2[1])));
			float poids_26 = (sqrt((xyz_point[1]-xyz_2[2])*(xyz_point[1]-xyz_2[2]))/sqrt((xyz_1[1]-xyz_2[1])*(xyz_1[1]-xyz_2[1])));
			temp_1526 = (poids_15*temp_15 + poids_26*temp_26)/(poids_15+poids_26);
		}
		if(xyz_3[1] == xyz_4[1]){
			temp_3748 = temp_37;
		} else {
			float poids_37 = (sqrt((xyz_point[1]-xyz_3[1])*(xyz_point[1]-xyz_3[1]))/sqrt((xyz_3[1]-xyz_4[1])*(xyz_3[1]-xyz_4[1])));
			float poids_48 = (sqrt((xyz_point[1]-xyz_4[1])*(xyz_point[1]-xyz_4[1]))/sqrt((xyz_3[1]-xyz_4[1])*(xyz_3[1]-xyz_4[1])));
			temp_3748 = (poids_37*temp_37 + poids_48*temp_48)/(poids_37+poids_48);
		}

		//moyenne sur X
		float temp_final;
		if(xyz_1[0] == xyz_3[0]){
			temp_final = temp_1526;
		} else {
			float poids_1526 = (sqrt((xyz_point[0]-xyz_1[0])*(xyz_point[0]-xyz_1[0]))/sqrt((xyz_1[0]-xyz_3[0])*(xyz_1[0]-xyz_3[0])));
			float poids_3748 = (sqrt((xyz_point[0]-xyz_3[0])*(xyz_point[0]-xyz_3[0]))/sqrt((xyz_1[0]-xyz_3[0])*(xyz_1[0]-xyz_3[0])));
			temp_final = (poids_1526*temp_1526 + poids_3748*temp_3748)/(poids_1526+poids_3748);
		}

		//TEST
		//return temp_final;
		//return (sqrt((xyz_point[2]-xyz_1[2])*(xyz_point[2]-xyz_1[2]))/sqrt((xyz_5[2]-xyz_1[2])*(xyz_5[2]-xyz_1[2])));

		/*
		float val_test = check_text_coord(voxel_1)[2];
		if(val_test < 1.0 && val_test >= 0.0){
			return 0.4;
		} else if(val_test < 2.0 && val_test >= 1.0){
			return 0.5;
		} else if(val_test < 3.0 && val_test >= 2.0){
			return 0.6;
		} else if(val_test < 4.0 && val_test >= 3.0){
			return 0.7;
		} else if(val_test < 5.0 && val_test >= 4.0){
			return 0.8;
		} else if(val_test < 6.0 && val_test >= 5.0){
			return 0.9;
		} else {
			return 0.0;
		}
		*/
		/*
		if(int(xyz_5[2]) == int(xyz_1[2])){
			return 1.0;
		} else if(xyz_5[2] > xyz_1[2]){
			return 0.5;
		} else {
			return 0.0;
		}
		*/
		/*
		float val_test = xyz_1[2];
		if(val_test < 27.9 && val_test >= 27.8){
			return 0.4;
		} else if(val_test < 29.4 && val_test >= 29.3){
			return 0.5;
		} else if(val_test < 31.4 && val_test >= 31.3){
			return 0.6;
		} else if(val_test < 39.6 && val_test >= 39.5){
			return 0.7;
		} else if(val_test < 59.8 && val_test >= 59.7){
			return 0.8;
		} else if(val_test < 76.8 && val_test >= 76.7){
			return 0.9;
		} else {
			return 0.0;
		}
		*/
		return sample_z(vec3(0.5,0.5,voxel_1[2]/7.0))/1000.0;
		// l'erreur est dans la récupération des valeurs xyz, elles n'ont aucun sens
		//elles sont les mêmes partout et bcp plus énormes qu'elles ne devraient
		// pourtant les valeurs de voxel_1 et voxel_5, et leurs résultats renvoyés par la fonction cehcoord sont corrects

		//même la fonction ci-dessus renvoit tjt le même résultat

	  }


      void main() {

      		//conversion des coordonnées contenues dans v_position, exprimées dans le référentiel de la scène 3D, en coordonnées voxel, exprimées dans le référentiel du cube de température 3D
      		float voxel_position_x = ((v_position[0]/cst_X) - x_min)/(x_max - x_min)*u_size[0];
      		float voxel_position_y = u_size[1]-(-(v_position[2]/cst_Y) - y_min)/(y_max - y_min)*u_size[1];


      		float voxel_position_z = 0.0;

      		//les éléments situées en dehors de la zone couverte par le cube de température ne sont pas pris en compte
      		if(voxel_position_x > u_size[0] || voxel_position_x < 0.0){
      			discard;
      		}
      		if(voxel_position_y > u_size[1] || voxel_position_y < 0.0){
      			discard;
      		}


      		if(type_model < 0.5 ){
      			//données TEB
      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			vec3 sample3D_coord_2;
      			float sample3D_val;
      			float sample3D_val_2;

      			//calcul des altitudes min et max correspondant au cube de températures
      			sample3D_size = vec3(u_size[0],u_size[1],7);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,0.0);
      			sample3D_val = texture(teb_limit, (sample3D_coord/sample3D_size).xyz).r;
      			sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,6.0);
      			sample3D_val_2 = texture(teb_limit, (sample3D_coord_2/sample3D_size).xyz).r;

      			// les éléments au dessus ou en dessous du cube de température ne sont pas traités
      			if(sample3D_val*cst_Z > v_position[1]){
      				discard;
      			} else if(sample3D_val_2*cst_Z < v_position[1]){
      				discard;
      			} else {
      				for(int i=1; i< 7; i++){
      					//calcul des altitudes des limites inférieures et supérieures de la cellule contenant l'élément traité
      					vec3 sample3D_coord_3;
      					vec3 sample3D_coord_4;
      					float sample3D_val_3;
      					float sample3D_val_4;
      					sample3D_coord_3 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      					sample3D_val_3 = texture(teb_limit, (sample3D_coord_3/sample3D_size).xyz).r;
      					sample3D_coord_4 = vec3(voxel_position_x,voxel_position_y,float(i));
      					sample3D_val_4 = texture(teb_limit, (sample3D_coord_4/sample3D_size).xyz).r;
      					if(sample3D_val_4*cst_Z > v_position[1]){
      						float z_min = sample3D_val_3;
      						float z_max = sample3D_val_4;
      						//calcul de la position z de l'élément traité, exprimé en voxel dans le référentiel du cube de température, à partir des altitudes des limites inférieures et supérieures de la cellule contenant l'élément traité
      						voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0;
      						break;
      					}
      				}
      			}


      		} else {
      			//données MESO_NH
      			vec3 sample3D_size;
      			vec3 sample3D_coord;
      			float sample3D_val;
      			vec3 sample3D_coord_2;
      			float sample3D_val_2;

      			//calcul des altitudes min et max correspondant au cube de températures
      			sample3D_size = vec3(u_size[0],u_size[1],33);
      			sample3D_coord = vec3(voxel_position_x,voxel_position_y,1.0);
      			sample3D_val = texture(meso_limit, (sample3D_coord/sample3D_size).xyz).r;
      			sample3D_coord_2 = vec3(voxel_position_x,voxel_position_y,2.0);
      			sample3D_val_2 = texture(meso_limit, (sample3D_coord_2/sample3D_size).xyz).r;

      			// les éléments au dessus ou en dessous du cube de température ne sont pas traités
      			if(sample3D_val_2*cst_Z > v_position[1]){

      				if(sample3D_val*cst_Z > v_position[1]){
      					discard;
      				}
      				else {
      					voxel_position_z = 6.0;
      				}
      			} else {
      				for(int i=3; i< 32; i++){
      					//calcul des altitudes des limites inférieures et supérieures de la cellule contenant l'élément traité
      					vec3 sample3D_coord_3;
      					vec3 sample3D_coord_4;
      					float sample3D_val_3;
      					float sample3D_val_4;
      					sample3D_coord_3 = vec3(voxel_position_x,voxel_position_y,float(i-1));
      					sample3D_val_3 = texture(meso_limit, (sample3D_coord_3/sample3D_size).xyz).r;
      					sample3D_coord_4 = vec3(voxel_position_x,voxel_position_y,float(i));
      					sample3D_val_4 = texture(meso_limit, (sample3D_coord_4/sample3D_size).xyz).r;
      					if(sample3D_val_4*cst_Z > v_position[1]){
      						float z_min = sample3D_val_3;
      						float z_max = sample3D_val_4;
      						//calcul de la position z de l'élément traité, exprimé en voxel dans le référentiel du cube de température, à partir des altitudes des limites inférieures et supérieures de la cellule contenant l'élément traité
      						voxel_position_z = (v_position[1] - z_min*cst_Z)/(z_max*cst_Z - z_min*cst_Z) + float(i) - 1.0 + 5.0;
      						break;
      					}
      				}
      			}
      		}


      		vec3 voxel_position = vec3(voxel_position_x,voxel_position_y,voxel_position_z);

      		if(sbl_meso_level[int(voxel_position_z)] == false){
      			discard;
      		} else {
      			//calcul, selon le mode sélectionné pour l'échelle de couleur, d'une valeur val entre 0 et 1 qui va servir à récupérer la couleur d'un pixel dans l'image chargée dans u_cmdata
      			float val = 0.0;
      			if(active_color_control == 1){
      				// mode 1, val est calculée à partir de la température, en utilisant les valeurs associées aux bornes de l'histogramme de températures
      				//note: la valeur obtenue pour val peut prendre n'importe quelle valeur entre 0.5/6.0 et 5.5/6.0. Mais l'image chargée dans u_cmdata représentant une échelle discrète de couleur, la variation de couleur n'est pas continue dans la scène 3D.
      				float firstval;
					  if(plane_type_control == 0){
						firstval = sample1(voxel_position/u_size);
					  }else if(plane_type_control == 1){
						firstval = average_sample(voxel_position);
					  }	else if(plane_type_control == 2){
						firstval = average_sample_2(voxel_position,v_position);
					}

      					if(firstval<u_clim[0]){
      						//discard;
      						val = 0.5/6.0;
      					} else if(firstval>u_clim[1]){
      						//discard;
      						val = 5.5/6.0;
      					} else{
      						val = (firstval - u_clim[0])/(u_clim[1] - u_clim[0]);
      					}

						//TEST
						//val=firstval;

      			} else if(active_color_control == 2){
      				// mode 2, val est calculée à partir de la température, en utilisant des bornes fixes pour chaque couleur
      				float anteval = sample1(voxel_position/u_size);
      				if(anteval<300.8 && anteval >= 300.02){
      					val = 5.5/6.0;
      				} else if(anteval<300.02 && anteval >= 299.64){
      					val = 4.5/6.0;
      				} else if(anteval<299.64 && anteval >= 299.36){
      					val = 3.5/6.0;
      				} else if(anteval<299.36 && anteval >= 298.98){
      					val = 2.5/6.0;
      				} else if(anteval<298.98 && anteval >= 298.40){
      					val = 1.5/6.0;
      				} else if(anteval<298.40 && anteval >= 297.92){
      					val = 0.5/6.0;
      				}

      			} else {
      				// mode 2, une valeur est définie pour chaque niveau
      				//val = fract(float(int(voxel_position_z))/(u_size[2]/7.0));
      				//val = mod((float(int(voxel_position[2]))+0.5),6.0)/6.0;
      				val = (6.0-mod((float(int(voxel_position[2]))+0.5),6.0))/6.0;
      			}


      		//récupération de la couleur
      		vec4 point_color_4 = texture2D(u_cmdata, vec2(val, 0.5));

			vec3 point_color_3 = vec3(point_color_4[0],point_color_4[1],point_color_4[2]);
			//vec3 point_color_3 = vec3(val,0.0,0.0);

      		float d = light_ambient;
      		d += max(0.0,dot(Normal,light_direction[0]));
      		d += max(0.0,dot(Normal,light_direction[1]));

      		gl_FragColor = vec4(d * point_color_3,transparency);
      		}
      }
    </script>
    <script type="module">
      import { init } from "./js/initialisation.js";
      import { render } from "./js/creative_functions.js";
      import { initialise } from "./js/menu.js";
      import {} from "./js/filter-sliders.js";
      import {} from "./js/footprint.js";
      import {} from "./js/dynamique_div.js";

      init();
      render();
      initialise();
    </script>
  </body>
</html>
